[block]
Complexity:[br]
The complexity of operations on binary search trees is based on the trees height. The height of an ideal binary search tree is log(n), where n is the number of nodes in the tree.[br]
In the worst case, when the tree is just a linked list, the height is n.[br][br]
Insert: In the worst case, when the new node has to be inserted at the deepest point of the tree, the runtime is proportional to the height.[br]
In the specific implementation, there are two accesses per visited node plus one access for inserting the new node.[br]
The number of accesses therefore amounts to 2*n+1 in the worst case and 2*log(n)+1 in the average case.[br][br]
Delete: During deletion, the tree is not always traversed to its deepest position, but in the worst case this will happen.[br]
Therefore, the runtime is proportional to the trees height, just like the insert operations runtime. This is also the case, even if a node with two child nodes is deleted.[br]
In the specific implementation, there are five accesses for each visited node while searching for the node to delete and one access per node while searching for the biggest node in the left subtree.
[/block]
[block]
Overall there were {0} reading and {1} writing accesses, spred over {2} insertions and {3} deletions.[br]
Insertions on average required {4} accesses relative to the height and {5} accesses relative to the number of nodes.[br]
Deletions on average required {6} accesses relative to the height and {7} accesses relative to the number of nodes.[br]
The mean height during the operations amounts to {8} * number of nodes.
[/block]
[block]
Related algorithms and data structures:[br]
Binary search tree - search[br]
Traversal of binary search trees[br]
Sorting with binary search trees[br]
Self-balancing binary search tree
[/block]