[block]
Komplexität:[br]
Die Komplexität für Operationen auf binären Suchbäumen hängt von deren Höhe ab. Die Höhe eines optimalen binären Suchbaums beträgt log(n), wobei n die Anzahl der Knoten bezeichnet.[br]
Im schlechtesten Fall, also wenn es nur rechte oder nur linke Kinder gibt, beträgt die Höhe n.[br]
Einfügen: Im schlechtesten Fall, also wenn der neue Knoten an der tiefsten Stelle des Baums eingefügt werden muss, ist die Laufzeit dieser Operation proportional zur Höhe des Baumes.[br]
Beträgt die Höhe also log(n), liegt die Laufzeit des Einfügens in O(log(n)), bei einer Höhe von n liegt die Laufzeit in O(n).[br]
In der konkret vorliegenden Implementierung finden pro besuchtem Knoten durchschnittlich zwei Zugriffe statt, sowie ein Zugriff zum Einfügen. Die Anzahl der Zugriffe beträgt also im schlechtesten Fall 2*n+1, im Durchschnitt 2*log(n)+1.[br][br]
Löschen: Beim Löschen wird der Baum zwar nicht immer bis zur tiefsten Stelle durchlaufen, im schlechtesten Fall kann dies allerdings geschehen.[br]
Daher ist auch die Laufzeit dieser Operation von der Höhe des Baums abhängig und liegt bei einem ausgeglichenen Baum in O(log(n)), im schlechtesten Fall liegt sie in O(n).[br]
Dies ist auch dann der Fall, wenn ein Knoten mit zwei Kindern gelöscht wird.[br]
In der konkreten Implementierung finden während der Suche nach dem zu löschenden Knoten durchschnittlich 5 Zugriffe pro Ebene statt, auf der Suche nach dem größten Kind genau ein Zugriff pro Ebene des Baums.
[/block]
[block]
Insgesamt fanden {0} lesende und {1} schreibende Zugriffe statt, verteilt auf {2} Einfüge- und {3} Löschoperationen.[br]
Einfügeoperationen benötigten durchschnittlich {4} Zugriffe in Relation zur Höhe des Baums und {5} Zugriffe in Relation zur Anzahl der Knoten im Baum.[br]
Löschoperationen benötigten durchschnittlich {6} Zugriffe in Relation zur Höhe des Baums und {7} Zugriffe in Relation zur Anzahl der Knoten im Baum.[br]
Die durchschnittliche Höhe des Baums während den Operationen beträgt {8} * Anzahl der Knoten.
[/block]
[block]
Verwandte Algorithmen und Datenstrukturen:[br]
Suche in binären Suchbäumen[br]
Traversierung von Binärbäumen[br]
Sortierung mit binären Suchbäumen: Aus einer Liste wird ein binärer Suchbaum aufgebaut und anschließend traversiert.[br]
Selbstausgleichender binärer Suchbaum
[/block]