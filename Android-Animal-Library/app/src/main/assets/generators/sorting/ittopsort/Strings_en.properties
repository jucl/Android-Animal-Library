# Strings_en.properties
titleAlgo=Topological Sorting (iterative)

header=Topological Sorting
titleIntro=Introduction
titleDescription=Formal Description
titleConclusion=Conclusion
descriptionTextFile=description_en
introTextFile=intro_en
sourceCodeFile=sourceCode_en
lblOuterIteration=While loop: $0. Iteration
lblInnerIteration=Successor loop: $0. Iteration
lblProgress=$0/$1 Nodes visited
conclusionFailure=The graph had cycles, so there is no topological order of the nodes.
conclusionSuccess=So $0 is a topological ordering for the graph.
conclusionNumIterations=There were $0 iterations necessary.
conclusionComplexity1=For each of the n nodes we have to visit each of it's m/n successors (m = number of edges).
conclusionComplexity2=Therefore the overall complexity is O(n*m/n) = O(m).


# Source code lines
sc1=L = [ ]
sc2=S = Set of nodes without incoming edges
sc3=while S != [ ] do
sc4=remove a node n from S
sc5=add n to tail of L
sc6=for each successor m of n do
sc7=remove edge (n,m)
sc8=if m has no incoming edges then
sc9=insert m into S
sc10=if graph G has edges then
sc11=return error (graph has at least one cycle)
sc12=else
sc13=return L

# Status texts
stSEmpty=S is empty.
stSNonEmpty=S is non-empty.
stRemS=Remove $0 from S.
stAddNToTail=Add $0 to tail of L.
stConsiderSuccessor=Consider successor $0 of $1.
stRemEdge=Remove edge from $0 to $1.
stInsertIntoS=Insert $0 into S.
stNoSuccessors=No successors of $0 left.
stNoIncomingEdges=$0 has no more incoming edges.
stIncomingEdges=$0 has incoming edges left
stEndEdgesLeft=There are edges left.
stEndNoEdgesLeft=There are no more edges left.
stEndSuccess=So we have finished successfully :).
stEndFailure=The graph has cycles so there exists no topological ordering :(.

# Chapter titles
chapIntro=Introduction
chapFormalDesc=Formal description
chapRunAlgo=Algorithmus in action
chapConclusion=Conclusion